var scmult = function (l, x) { return [l * x[0], l * x[1]] }; var vcadd = function (a, b) { return [a[0] + b[0], a[1] + b[1]] }; var minus = function (a, b) { return [a[0] - b[0], a[1] - b[1]] }; var dot = function (a, b) { return a[0] * b[0] + a[1] * b[1] }; var wedge = function (a, b) { return a[0] * b[1] - a[1] * b[0] }; var apply = function (A, x) { return vcadd(scmult(x[0], A[0]), scmult(x[1], A[1])) }; var mult = function (A, B) { return [apply(A, B[0]), apply(A, B[1])] }; function Transform(A, b) { this.A = A; this.b = b } Transform.prototype.css = function () { var A = this.A; var b = this.b; return 'matrix(' + A[0][0] + ',' + A[0][1] + ',' + A[1][0] + ',' + A[1][1] + ',' + b[0] + ',' + b[1] + ')' }; var cascade = function (T, U) { return new Transform(mult(T.A, U.A), vcadd(apply(T.A, U.b), T.b)) }; var rotate = function (c, s) { return [[c, s], [-s, c]] }; var rotscale = function (a, b) { var alen = dot(a, a); var sig = dot(a, b); var del = wedge(a, b); return rotate(sig / alen, del / alen) }; var justscale = function (a, b) { var alen = Math.sqrt(dot(a, a)); var blen = Math.sqrt(dot(b, b)); var scale = blen / alen; return rotate(scale, 0) }; var magnification = function (A) { return Math.abs((A[0][0] + A[1][1]) / 2) }; var scaleMatrix = function (A, l) { return [scmult(l, A[0]), scmult(l, A[1])] }; var zoom = function (s, d, allowRotation, minZoom, maxZoom) { var a = minus(s[1], s[0]); var b = minus(d[1], d[0]); var rs = allowRotation ? rotscale(a, b) : justscale(a, b); var mag = magnification(rs); if (mag < minZoom) { rs = scaleMatrix(rs, minZoom / mag) } else if (mag > maxZoom) { rs = scaleMatrix(rs, maxZoom / mag) } var rs0 = apply(rs, s[0]); var t = minus(d[0], rs0); return new Transform(rs, t) }; var avgVector = function (u, v, progress) { var u1 = scmult(1 - progress, u); var v1 = scmult(progress, v); return vcadd(u1, v1) }; var avgMatrix = function (A, B, progress) { return [avgVector(A[0], B[0], progress), avgVector(A[1], B[1], progress)] }; Transform.avg = function (Z, I, progress) { return new Transform(avgMatrix(Z.A, I.A, progress), avgVector(Z.b, I.b, progress)) }; var identity = new Transform([[1, 0], [0, 1]], [0, 0]); var defaults = function (param, val) { return (param === undefined) ? val : param }; var default_config = function (cfg, cfg_def) { var new_cfg = defaults(cfg, {}); for (var k in cfg_def) { new_cfg[k] = defaults(new_cfg[k], cfg_def[k]) } return new_cfg }; function Zoom(elem, config, wnd) { this.mayBeDoubleTap = null; this.isAnimationRunning = false; this.curTouch = 0; this.elem = elem; this.elemParent = elem.parentNode; this.activeZoom = identity; this.resultantZoom = identity; this.srcCoords = [0, 0]; this.destCoords = [0, 0]; var me = this; this.config = default_config(config, { "pan": false, "rotate": true, "minZoom": 0, "maxZoom": Infinity }); this.wnd = wnd || window; elem.style['will-change'] = 'transform'; elem.style['transform-origin'] = '0 0'; var getCoordsDouble = function (t) { var rect = elem.parentNode.getBoundingClientRect(); var oX = rect.left; var oY = rect.top; return [[t[0].pageX - oX, t[0].pageY - oY], [t[1].pageX - oX, t[1].pageY - oY]] }; var getCoordsSingle = function (t) { var rect = elem.parentNode.getBoundingClientRect(); var oX = rect.left; var oY = rect.top; var x = t[0].pageX - oX; var y = t[0].pageY - oY; return [[x, y], [x + 1, y + 1]] }; var getCoords = function (t) { return t.length > 1 ? getCoordsDouble(t) : getCoordsSingle(t) }; var setSrcAndDest = function (touches) { me.srcCoords = getCoords(touches); me.destCoords = me.srcCoords }; var setDest = function (touches) { me.destCoords = getCoords(touches) }; var handleTouchEvent = function (cb) { return function (evt) { evt.preventDefault(); if (me.isAnimationRunning) { return false } var touches = evt.touches; if (!touches) { return false } cb(touches) } }; this._handleZoom = handleTouchEvent(function (touches) { var numOfFingers = touches.length; if (numOfFingers !== me.curTouch) { me.curTouch = numOfFingers; me.finalize(); if (numOfFingers !== 0) { setSrcAndDest(touches) } } else { setDest(touches); me.previewZoom() } }); this._handleTouchStart = handleTouchEvent(function (touches) { if (touches.length === 1) { if (me.mayBeDoubleTap !== null) { me.wnd.clearTimeout(me.mayBeDoubleTap); me.reset(); me.mayBeDoubleTap = null } else { me.mayBeDoubleTap = me.wnd.setTimeout(function () { me.mayBeDoubleTap = null }, 300) } } }); this.elemParent.addEventListener('touchstart', this._handleTouchStart); this.elemParent.addEventListener('touchstart', this._handleZoom); this.elemParent.addEventListener('touchmove', this._handleZoom); this.elemParent.addEventListener('touchend', this._handleZoom) } Zoom.prototype.destroy = function () { this.elemParent.removeEventListener('touchstart', this._handleTouchStart); this.elemParent.removeEventListener('touchstart', this._handleZoom); this.elemParent.removeEventListener('touchmove', this._handleZoom); this.elemParent.removeEventListener('touchend', this._handleZoom); this.elem.style['will-change'] = null; this.elem.style['transform-origin'] = null; this.elem.style.transform = null }; Zoom.prototype.previewZoom = function () { var zoomLevel = magnification(this.activeZoom.A); var minZoom = this.config['minZoom'] / zoomLevel; var maxZoom = this.config['maxZoom'] / zoomLevel; var additionalZoom = zoom(this.srcCoords, this.destCoords, this.config.rotate, minZoom, maxZoom); this.resultantZoom = cascade(additionalZoom, this.activeZoom); this.repaint() }; Zoom.prototype.setZoom = function (newZoom) { this.resultantZoom = newZoom; this.repaint() }; Zoom.prototype.finalize = function () { this.activeZoom = this.resultantZoom }; Zoom.prototype.repaint = function () { this.elem.style.transform = this.resultantZoom.css() }; Zoom.prototype.reset = function () { if (this.wnd.requestAnimationFrame) { this.isAnimationRunning = true; var Z = this.activeZoom; var startTime = null; var me = this; var step = function (time) { if (!startTime) { startTime = time } var progress = (time - startTime) / 100; if (progress >= 1) { me.setZoom(identity); me.isAnimationRunning = false } else { me.setZoom(Transform.avg(Z, identity, progress)); me.wnd.requestAnimationFrame(step) } }; this.wnd.requestAnimationFrame(step) } else { this.setZoom(identity) } }; Zoom.prototype['reset'] = Zoom.prototype.reset; if (typeof exports === "undefined") { window['Zoom'] = Zoom } else { exports['Zoom'] = Zoom }